/*
 * Generate Pink Noise using Gardner method.
 *
 * Optimization suggested by James McCartney uses a tree
 * to select which random value to replace.

 * x x x x x x x x x x x x x x x x
 * x   x   x   x   x   x   x   x   
 * x       x       x       x       
 *  x               x               
 *    x   
 *
 * Tree is generated by counting trailing zeros in an increasing index.
 * When the index is zero, no random number is selected.
 *
 * @author Phil Burk  http://www.softsynth.com
 */
#include <stdio.h>
#include <math.h>
#include "instrument-includes.h"

#define PINK_MAX_RANDOM_ROWS   (30)
#define PINK_RANDOM_BITS       (24)
#define PINK_RANDOM_SHIFT      ((sizeof(long)*8)-PINK_RANDOM_BITS)

#define SCALE                   (1.0 / ((double)G_MAXLONG + 2.0))

typedef struct
{
  gdouble   rows[PINK_MAX_RANDOM_ROWS];
  gdouble   running_sum;   /* Used to optimize summing of generators. */
  int       index;        /* Incremented each sample. */
  int       index_mask;    /* Index wrapped by ANDing with this mask. */
}
PinkNoise;

#if 0
/* Calculate pseudo-random 32 bit number based on linear congruential method. */
static unsigned long GenerateRandomNumber( void )
{
    /* Change this seed for different random sequences. */
    static unsigned long randSeed = 22222;
    randSeed = (randSeed * 196314165) + 907633515;
    return randSeed;
}
#endif

static double *
pink_noise_synth (BbInstrument *instrument,
                  BbRenderInfo *render_info,
                  GValue       *params,
                  guint        *n_samples_out)
{
  /* Setup PinkNoise structure for N rows of generators. */
  PinkNoise pink;
  guint num_rows = PINK_MAX_RANDOM_ROWS;
  gdouble new_random;

  /* Calculate maximum possible signed random value.
     Extra 1 for white noise always added. */
  gdouble final_scale = 1.0 / (double)(num_rows + 1);

  guint i;
  guint n = render_info->note_duration_samples;
  gdouble *rv;

  *n_samples_out = n;
  rv = g_new (gdouble, n);

  pink.index = 0;
  pink.index_mask = (1<<num_rows) - 1;

  /* Initialize rows. */
  for(i = 0; i < num_rows; i++)
    pink.rows[i] = 0;
  pink.running_sum = 0;

  for (i = 0; i < n; i++)
    {
      double sum;
      /* Increment and mask index. */
      pink.index = (pink.index + 1) & pink.index_mask;
      /* If index is zero, don't update any random values. */
      if (pink.index != 0)
        {
          /* Determine how many trailing zeros in PinkIndex. */
          /* This algorithm will hang if n==0 so test first. */
          guint num_zeros = 0;
          guint tmp = pink.index;
          while((tmp & 1) == 0)
            {
              tmp >>= 1;
              num_zeros++;
            }
          /* Replace the indexed ROWS random value.
           * Subtract and add back to RunningSum instead of adding all the random
           * values together. Only one changes each time.
           */
          pink.running_sum -= pink.rows[num_zeros];
          new_random = g_random_double_range (-1.0, 1.0);
          pink.running_sum += new_random;
          pink.rows[num_zeros] = new_random;
        }

      /* avoid accumulating roundoff error too much */
      if (i % 1024 == 0)
        {
          gdouble cur_sum = 0;
          guint n;
          for (n = 0; n < num_rows; n++)
            cur_sum += pink.rows[n];
          pink.running_sum = cur_sum;
        }


      /* Add extra white noise value. */
      new_random = g_random_double_range (-1.0, 1.0);
      sum = pink.running_sum + new_random;
      rv[i] = final_scale * sum;
    }
  return rv;
}

BB_INIT_DEFINE(_bb_pink_noise_init)
{
  BbInstrument *instrument =
  bb_instrument_new_generic ("pink_noise", param_spec_duration (), NULL);
  instrument->synth_func = pink_noise_synth;
}

